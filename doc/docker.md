# Docker

__Docker__ — это открытая платформа для разработки, доставки и эксплуатации приложений. C помощью технологии Docker (контейнеризации) можно разделить исходное приложение на несколько компонентов, которые взаимодействие между которыми возможно реализовать. Подобный подход может привнести разные методы реализации компонентов, тем самым предоставляя разработчику широкий спектр возможностей. Благодаря этому разработчику предоставляется возможность создания микро-сервисных архитектур.

>Микросервисная архитектура — вариант сервис-ориентированной архитектуры программного обеспечения, направленный на взаимодействие насколько это возможно небольших, слабо связанных и легко изменяемых модулей — микросервисов, получивший распространение в середине 2010-х годов в связи с развитием практик гибкой разработки и DevOps


## Структура
Нужно знать о  трех компонентах:

1. __Образы (Images)__ – это read-only шаблон, на который инженер в зависимости от требований доставляет дополнительные утилиты, библиотеки;
2. __Контейнер__ –  сущности в  которых содержится все, что нужно для работы приложения. Каждый контейнер создается из образа. Каждый контейнер изолирован от операционной системы и является безопасной платформой для приложения;
3. __Реестры (registries)__ – это контейнер, управляемый Docker, который может использоваться для размещения частных репозиториев будь личный или репоизорий компании.


## Dockerfile

Dockerfile – это сценарий, который состоит из последовательности команд и аргументов, необходимых для создания образа. Такие сценарии упрощают развёртывание и процесс подготовки приложения к запуску.

Создается виртуальное окружение, внутри которого будет собираться/исполняться программа.

## Команды Dockerfile

1. __ADD__ - имеет два аргумента: источник и назначение. Команда копирует исходный файл в целевой каталог файловой системы контейнера;

2. __RUN__ - запускает указанную команду внутри контейнера с учётом всех аргументов;

3. __CMD__ - аналогично команде RUN, можно использовать для запуска других команд. В отличие от RUN, эту команду нельзя использовать при сборке, она выполняет команду при запуске контейнера;

4. __ENTRYPOINT__ - задаёт команду по умолчанию, которое используется во время создания контейнера;

5. __ENV__ - задаёт переменные среды в формате «ключ = значение»;

6. __EXPOSE__ - задаёт порт, с помощью которого приложение в контейнере может взаимодействовать с внешним окружением;

7. __FROM__ - определяет базовый образ, на основе которого будет собран новый образ;

8. __USER__ - задаёт имя пользователя;

9. __MAINTAINER__ - Эта команда не выполняется, она позволяет задать имя автора;

10. __VOLUME__ - разрешает контейнеру доступ к заданному каталогу на локальной машине;

11. __WORKDIR__ - устанавливает рабочий каталог, в котором будет выполнена команда, указанная в __CMD__;

## Example

```yml
1 # Используем официальный образ Node с постфиксом slim
2 FROM node:current-slim
3
4 # Задаем рабочую директорию внутри образа
5 WORKDIR /usr/src/app
6
7 # Копируем файл с хоста в обрах
8 COPY package.json .
9
10 # Инициализируем зависимости внутри образа 
11 RUN npm install
12 
13 # Биндим порт, по которому можем вызывать наше приложение извне
14 EXPOSE 8080
15
16 # Стартуем
17 CMD ['npm', 'start']
18
19 # Копируем весь код с хоста в обрах
20 COPY . .
```

## Usage
```yml
1 # Собираем контейнер из Dockerfile в текущей директории с присаванием тэга 'nodejs'
2 docker build --tag noodejs .
3 
4 # Стартуем контейнер с портами 8000 - на хост машине и 8080 - внутри вирутального окружения
5 docker run --p 8000:8080 --tag nodejs
```

## Дополнение

> В основне каждого образа лежит Linux дистрибутив, а это означает, что мы после запуска Dockerfile получаем маленький образ Linux со всеми подготовленными зависимостями для исполнения программы.

В вышеизложенном примере мы запустили Linux дистрибутив с настроенным Node JS окружением, в который мы пробросили весь проект и инициализировали зависимсоти Node JS.

